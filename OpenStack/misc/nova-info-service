#!/usr/bin/env python
import sqlalchemy
import datetime
import json
import web

"""
REST service that provides information about cloud resources, machine types,
and project quotas.  Should be run on each management node in the cloud.
"""

NOVA_CONF = '/etc/nova/nova.conf'
URL_PREFIX = '/nova-info'

urls = (
	'%s/resources' % URL_PREFIX, 'Resources',
	'%s/machinetypes' % URL_PREFIX, 'MachineTypes',
	'%s/quotas/(.*)' % URL_PREFIX, 'Quotas'
)

web.config.debug = False
app = web.application(urls, globals())

max_cores = None
with open(NOVA_CONF, 'r') as f:
	for line in f:
		if line.startswith('--sql_connection'):
			db_url = line.strip().split('=', 1)[1]
		elif line.startswith('--max_cores'):
			max_cores = int(line.strip().split('=', 1)[1])

engine = sqlalchemy.create_engine(db_url)

class CachedContent():
	EXPIRY_TIME = datetime.timedelta(seconds=10)

	def __init__(self):
		self.last_updated = datetime.datetime.today() - self.EXPIRY_TIME

	def update(self, *args):
		"""Implement to update self.content"""
		raise NotImplementedError

	def GET(self, *args):
		time_since_update = datetime.datetime.today() - self.last_updated
		if time_since_update > self.EXPIRY_TIME:
			self.update(*args)
			self.last_updated = datetime.datetime.today()

		web.header('Content-Type', 'application/json; charset=utf-8')
		return json.dumps(self.content)

class Resources(CachedContent):
	def update(self):
		node_usage = engine.execute(
			"SELECT host, "
			"vcpus,vcpus_used, "
			"memory_mb,memory_mb_used, "
			"memory_mb-memory_mb_used AS memory_mb_avail "
			"FROM compute_nodes "
			"INNER JOIN services AS s ON service_id=s.id "
			"WHERE s.binary='nova-compute' AND s.deleted=0 AND s.disabled=0"
		)
	
		resources = {}	
		resources['nodes'] = {}
		for row in node_usage:
			host = row['host']
			resources['nodes'][host] = dict(row.items())
			resources['nodes'][host]['vcpus'] = max_cores or row['vcpus']
			resources['nodes'][host]['vcpus_avail'] = resources['nodes'][host]['vcpus'] - resources['nodes'][host]['vcpus_used']
			del resources['nodes'][host]['host']
		
		resources['total'] = {}
		for node in resources['nodes'].itervalues():
			for (key, value) in node.items():
				try:
					resources['total'][key] += value
				except KeyError:
					resources['total'][key] = value

		node_usage.close()
		self.content = resources

class MachineTypes(CachedContent):
	def update(self):
		result = engine.execute(
			"SELECT name,vcpus,memory_mb,local_gb,swap "
			"FROM instance_types "
			"WHERE deleted=0"
		)

		machine_types = {}
		for row in result:
			machine_types[row['name']] = dict(row.items())
			del machine_types[row['name']]['name']

		result.close()
		self.content = machine_types

class Quotas():
	def GET(self, project):
		conn = engine.connect()

		total = conn.execute(
			"SELECT instances,cores,volumes,gigabytes,floating_ips "
			"FROM quotas "
			"WHERE project_id=%(project)s AND deleted=0",
			project=project
		)

		quotas = {}
		try:
			quotas['total'] = dict(total.first())
		except TypeError:
			return "Unknown project"

		used_compute = conn.execute(
			"SELECT COUNT(1) as instances, "
			"IFNULL(CAST(SUM(vcpus) AS SIGNED), 0) as cores "
			"FROM instances "
			"WHERE project_id=%(project)s AND deleted=0",
			project=project
		)

		used_volume = conn.execute(
			"SELECT COUNT(1) as volumes, "
			"IFNULL(CAST(SUM(size) AS SIGNED), 0) as gigabytes "
			"FROM volumes "
			"WHERE project_id=%(project)s AND deleted=0",
			project=project
		)

		used_ip = conn.execute(
			"SELECT COUNT(1) as floating_ips "
			"FROM floating_ips "
			"WHERE project_id=%(project)s AND deleted=0",
			project=project
		)

		quotas['used'] = dict(used_compute.first().items() + used_volume.first().items() + used_ip.first().items())
		
		conn.close()
		web.header('Content-Type', 'application/json; charset=utf-8')
		return json.dumps(quotas)

if __name__ == '__main__':
	app.run()
